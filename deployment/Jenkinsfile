def remote = [:]
pipeline {
    agent {
        label 'docker'
    }

    parameters {
        gitParameter(
            type: 'PT_BRANCH', 
            name: 'BRANCH', 
            branchFilter: 'origin/(.*)', 
            sortMode: 'DESCENDING_SMART',
            defaultValue: 'main',
            quickFilterEnabled: true
        )
        string(
            name: 'HOST',
            defaultValue: '192.168.56.7',
            description: 'Host for deploy'
        )
        booleanParam(
            name: 'ROLLBACK',
            defaultValue: false,
            description: 'Откатить на версию $TAG'
        )
        booleanParam(
            name: 'RUN_TEST',
            defaultValue: true,
            description: 'Запуск тестов'
        )
        string(
            name: 'TAG',
            defaultValue: '',
            description: 'Тэг (:bookstore-1) для rollback'
        )
    }
    environment {
        DOCKER_REPO = 'ivankhodyrev/bookstore-app'
        DOCKER_TOKEN = credentials('docker_token')
        REPO_USER = 'ivankhodyrev'
        GIT_URL = 'git@github.com:ioannsnakej/diplom.git'
        PRJ_DIR = '/home/jenkins/bookstore-app'
        DB_USER="user"
        DB_NAME="bookstore"
        DB_HOST="db"
    }

    stages {
      //Клонирую репо на jenkins-agent
        stage('Checkout repo'){
            steps {
                script {
                    sh """
                        #!/bin/bash
                        set -ex
                        test -d ${env.PRJ_DIR} || git clone ${env.GIT_URL} ${env.PRJ_DIR}
                        cd ${env.PRJ_DIR}
                        git checkout ${params.BRANCH}
                        git pull
                    """
                }
            }
        }
    //Собираю образ на jenkins-agente
        stage('Build image') {
            when {
                expression { params.RUN_TEST && !params.ROLLBACK }
            }
            steps {
                sh """
                    docker build -t ${env.DOCKER_REPO}:${BUILD_NUMBER} .
                """
            }
        }
    //Тестирую этот образ на jenkins-agente
        stage('Run tests'){
            when {
                expression { params.RUN_TEST && !params.ROLLBACK }
            }
            steps {
                warnError('Test failed'){
                    sh """
                        #!/bin/bash
                        set -e
                        docker rm -f \$(docker ps -a -q) || true
                        docker network create tests 2>/dev/null || true
                        docker run -d --name db \
                            -e POSTGRES_USER=postgres \
                            -e POSTGRES_PASSWORD=postgres \
                            -e POSTGRES_DB=mydb \
                            --network=tests \
                            postgres:16
                        echo "Waiting for db.."
                        sleep 15
                        docker exec db psql -U postgres -d mydb -c "
                            CREATE TABLE IF NOT EXISTS books (
                                id SERIAL PRIMARY KEY,
                                title VARCHAR(200) NOT NULL,
                                author VARCHAR(100) NOT NULL,
                                price DECIMAL(10,2) NOT NULL,
                                count INTEGER DEFAULT 0
                            );
                        "
                        docker run -d --name backend \
                            -e DB_USER=postgres \
                            -e DB_PASS=postgres \
                            -e DB_NAME=mydb \
                            -e DB_HOST=db \
                            --network=tests \
                            ${env.DOCKER_REPO}:${BUILD_NUMBER}
                        sleep 10
                        docker exec backend python -m pytest app/tests_app.py -v --disable-warnings --maxfail=1
                        docker rm -f backend db
                        docker network rm tests
                    """
                }
            }
        }
    //Пушу собранный образ с jenkins-agenta в свой dockerhub
        stage('Push image'){
            when {
                expression { !params.ROLLBACK }
            }
            steps {
                sh """
                    docker login -u ${env.REPO_USER} -p ${env.DOCKER_TOKEN}
                    docker push ${env.DOCKER_REPO}:${BUILD_NUMBER}
                    docker logout
                """
            }
        }

        stage('Deploy'){
            when {
                expression { !params.ROLLBACK }
            }
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-key', keyFileVariable: 'private_key', usernameVariable: 'username')]) {
                    script {
                        remote.name = "${params.HOST}"
                        remote.host = "${params.HOST}"
                        remote.user = "${username}"
                        remote.identity = readFile "${private_key}"
                        remote.allowAnyHosts = true
                    }
                    sshCommand remote: remote, command: """
                        set -ex; set -o pipefail
                        mkdir -p ${env.PRJ_DIR}
                        chown -R jenkins:jenkins ${env.PRJ_DIR}
                        mkdir -p ${env.PRJ_DIR}/nginx
                        mkdir -p ${env.PRJ_DIR}/app
                        mkdir -p ${env.PRJ_DIR}/app/static
                    """
                    sh """
                        scp compose.yml \
                        ${remote.user}@${remote.host}:${env.PRJ_DIR}/compose.yml

                        scp nginx/bookstore.conf \
                        ${remote.user}@${remote.host}:${env.PRJ_DIR}/nginx/

                        scp app/init_db.sql \
                        ${remote.user}@${remote.host}:${env.PRJ_DIR}/app/

                        scp app/static/* \
                        ${remote.user}@${remote.host}:${env.PRJ_DIR}/app/static/
                    """
                    sshCommand remote: remote, command: """
                        set -ex; set -o pipefail
                        cd ${env.PRJ_DIR}
                        if [ -f .env ] && grep 'DB_PASS' .env; then
                            DB_PASS=\$(grep 'DB_PASS' .env | cut -d= -f2 | tr -d '\"')
                        else
                            DB_PASS=\$(openssl rand -base64 9 | tr -dc 'A-Za-z0-9' | head -c12)
                        fi
                        > .env
                        {
                            echo "APP_IMAGE=${env.DOCKER_REPO}:${BUILD_NUMBER}"
                            echo "DB_USER=${env.DB_USER}"
                            echo "DB_NAME=${env.DB_NAME}"
                            echo "DB_HOST=${env.DB_HOST}"
                            echo "DB_PASS=\${DB_PASS}"
                        } > .env
                        echo "✅ .env is ready"
                    """
                    sshCommand remote: remote, command: """
                        set -ex
                        cd ${env.PRJ_DIR}
                        docker compose pull
                        docker compose down -v --remove-orphans || true
                        docker compose up -d
                        docker compose ps
                    """
                }
            }
        }

        stage('Rollback'){
            when {
                expression { params.ROLLBACK == true }
            }
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-key', keyFileVariable: 'private_key', usernameVariable: 'username')]) {
                    script {
                        remote.name = "${params.HOST}"
                        remote.host = "${params.HOST}"
                        remote.user = "${username}"
                        remote.identity = readFile "${private_key}"
                        remote.allowAnyHosts = true
                    }
                    sshCommand remote: remote, command: """
                        set -ex; set -o pipefail
                        cd ${env.PRJ_DIR}
                        test -f .env || touch .env
                        sed -i '/APP_IMAGE=/d' .env
                        echo "APP_IMAGE="${env.DOCKER_REPO}:${env.TAG}" >> .env
                        docker compose up -d backend --force-recreate
                    """
                }
            }
        }
    }
    post {
        always {
            sh """
                docker system prune -f || true
            """
        }

        success {
            echo "✅ Deploy to ${params.HOST}:8000 success"
            echo "Image: ${env.DOCKER_REPO}:${env.TAG}"
        }

        failure {
            echo "❌ Pipeline failed!"
        }
    }
}